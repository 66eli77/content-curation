var Backbone = require("backbone");
var _= require("underscore");

var NodeModel = Backbone.Model.extend({
	defaults: {
		title:"Untitled",
		description:"This is the description generated by default",
		children: [],
		parent: null
    },
    urlRoot: function() {
		return window.Urls["node-list"]();//('node', this.id); // use django js reverse Urls.api('house', 12)
	},
	toJSON: function() {
	  var json = Backbone.Model.prototype.toJSON.apply(this, arguments);
	  json.cid = this.cid;
	  return json;
	},
	parse: function(response) {
	    return _(response).isArray()
	         ? response[0]
	         : response;
	},
	delete_node:function(){
		/*TODO: send to deleted tree*/
	},

    duplicate: function(parent_id){
    	/* Function in case want to append (Copy #) to end of copied content*/
    	var title = this.get("title");
    	
    	var list = this.attributes.title.split(" ");
    	if(list[list.length - 1] == "(Copy)"){ 				//model has been copied once before
    		list[list.length - 1] = "(Copy 2)";
    		title = list.join(" ");
    	}else if(list.length > 2 							//model has been copied multiple times
    			&& list[list.length-2] == "(Copy" 
    			&& list[list.length-1].includes(")")){
    		var copy_number = list[list.length-1].replace(")","");
    		list[list.length-1] = ++copy_number + ")";
			title = list.join(" ");
    	}else{
    		title += " (Copy)";
    	}
    	

		var data = {
			title: title,
			created : this.get("created"),
			modified : this.get("modified"),
			description: this.get("description"),
			deleted: this.get("deleted"),
			sort_order : this.get("sort_order"),
			license_owner : this.get("license_owner"),
			license: this.get("license"),
			kind: this.get("kind"),
			parent: parent_id
		};
		var node_data = new NodeModel(data);
		node_data.save(data, {async:false});
		this.copy_children(node_data, this.get("children"));
		return node_data;
	},
	copy_children:function(node, original_collection){
		var self = this;
		var parent_id = node.id;
		console.log("parent is " +parent_id);
		console.log("getting children...", original_collection);
		var copied_collection = new NodeCollection();
		copied_collection.get_all_fetch(original_collection);
		$(copied_collection.models).each(function(){
			console.log(parent_id, this);
			console.log("end",this.duplicate(parent_id));
		});
	}
});

var NodeCollection = Backbone.Collection.extend({
	model: NodeModel,
	save: function() {
        Backbone.sync("update", this, {url: this.model.prototype.urlRoot()});
	},
	url: function(){
       return window.Urls["node-list"]();
    },

    //get_all_fetch(ids) if get call fails, fetch from server, wrap to query multiple ids at once
   /* TODO: would be better to fetch all values at once */
    get_all_fetch: function(ids){
    	//Backbone.sync("read", this, {url: this.model.prototype.urlRoot()});
    	var to_fetch = new NodeCollection();
    	for(var i = 0; i < ids.length; i++){
    		var model = this.get({id: ids[i]});
    		
    		if(!model){
    			model = this.add({'id':ids[i]});
    			model.fetch({async:false});
    		}
    		to_fetch.add(model);
    	}
    	return to_fetch;
    	/*
    	var to_fetch = [];
    	var to_return = new NodeCollection();
    	var collection = this;
    	$(ids).each(function(){
			var model = collection.get({'id': this.valueOf()});
			if(model){
				to_return.add(model);
			} else{
				to_fetch.push({'id':this.valueOf()});
			}
		});

		to_return = this.add(to_fetch);
		to_return.fetch();
		//fetched.fetch();
*/
    },
    sort_by_order:function(){
    	this.comparator = function(node){
    		return node.get("sort_order");
    	};

    	this.sort();
    	/*
    	var sorted = new NodeCollection();
    	
    	sorted = this.sortBy(function(node){
    		console.log("node", node.get("title"));
    		return node.get("title").toLowerCase();
    	});
    	
    	return sorted;
    	*/
    },
});

var TopicTreeModel = Backbone.Model.extend({
	get_root: function(){
		var root = new NodeModel({id: this.get("root_node")});
		root.fetch({async:false});
		return root;
	},
	urlRoot: function() {
		return window.Urls["topictree-list"]();
	},
	defaults: {
		name: "Untitled Tree",
		is_published: false
	},
	parse: function(response) {
	    return _(response).isArray()
	         ? response[0]
	         : response;
	}
});

var TopicTreeModelCollection = Backbone.Collection.extend({
	model: TopicTreeModel,
	save: function() {
        Backbone.sync("update", this, {url: this.model.prototype.urlRoot()});
	},
	url: function() {
		return window.Urls["topictree-list"]();
	}
});

var ChannelModel = Backbone.Model.extend({
	urlRoot: function() {
		return window.Urls["channel-list"]();
	},
	defaults: {
		name: " ",
		editors: [],
		author: "Anonymous",
		license_owner: "No license found",
		description:" "
    },
    get_tree:function(tree_name){
    	var tree = new TopicTreeModel({id : this.get(tree_name)});
    	tree.fetch({async:false});
    	return tree;
    },

    update_root:function(data){
    	var channel = this;
    	$(["clipboard","deleted","draft"/*,"published"*/]).each(function(){
			var node = channel.get_tree(this.toString()).get_root();
			node.save(data);
		});
    },

    delete_channel:function(){
    	/* TODO: parallelize deleting*/
    	var channel = this;
    	var deleted_id = this.get_tree("deleted").id;
    	$(["clipboard","deleted","draft"/*,"published"*/]).each(function() {
		  	var tree = channel.get_tree(this);
		  	//channel.update_root({'parent' : deleted_id})
	    	tree.destroy();
	    	//TODO: Figure out how handling root nodes
	    	//var root = tree.get_root();
	    	//root.destroy();
		});
    	this.destroy();
    }
});

var ChannelCollection = Backbone.Collection.extend({
	model: ChannelModel,

	save: function() {
        Backbone.sync("update", this, {url: this.model.prototype.urlRoot()});
	},
	url: function() {
		return window.Urls["channel-list"]();
	},
	create_channel:function(data, timer){
		var channel_data = new ChannelModel(data);
		channel_data.fetch();
		if(channel_data.get("description").trim() == "")
			channel_data.set({description: "No description available."});
		var container = this;
		
		this.create(channel_data, {
			async: false,
			success:function(){
				$(["draft","clipboard","deleted",/*,"published"*/]).each(function(){
					container.create_tree(channel_data, this.toString());
				});
   			}
		});
    },
    create_tree:function(channel, tree_name){
    	console.log(tree_name + " tree is being created...");
    	var root_node = new NodeModel();
		root_node.save({title: channel.get("name")}, {
			async: false,
			success: function(){
				var tree = new TopicTreeModel();
				tree.save({
					channel: channel.id, 
					root_node: root_node.id,
					name: channel.get("name"),
					kind:"topic"
				}, {
					success: function(){
						channel.save(tree_name, tree.id);
						console.log(tree_name + " done.");
					}
				});
			}
		});
    }
});



module.exports = {
	NodeModel: NodeModel,
	NodeCollection: NodeCollection,
	TopicTreeModel:TopicTreeModel,
	TopicTreeModelCollection: TopicTreeModelCollection,
	ChannelModel: ChannelModel,
	ChannelCollection: ChannelCollection
}